# 実装方針

1. 健康状態からの遷移が可能な故障状態モデルを学習する。

1.をやった後に切り替え器を学習しようとしていたが、それは違うのでは？遷移を覚えさせたいならば、多分タイミングも覚えて貰った方が良い。
そうなると、関節の故障を感知するNNによるモデルの切り替えを行うようにして、例えば12関節用のモデルをまとめて学習させてしまう方が良いのでは？

取りあえず、上の実装は故障箇所が1箇所だけでも、多分関節の数のモデルが必要になる。これを一旦ミニマムとして実装して、その後複数関節故障とかのやつをやってみる。

👆ができたら、複数の1関節故障に耐えられるモデル（左脚全部に対応できるやつとか）を上の仕組みで学習させるやつをやってみる。この場合は、例えば左脚のどっかが壊れた時は全部同じモデルが選ばれるみたいにして、用意するモデルの個数を減らす事を目標にする。


# 実装についてのメモ

## まずIsaacLabでのtrainの仕組みはどうなっている？？
気になること
- modelとかはどの位インスタンスされているのか？これは流石に一個か

基本の学習はskrl.trainers.torch.SequentialTrainerで行う。
train.pyではskrl.trainers.torch.SequentialTrainer.train()を呼んで学習を実行する。
シングルエージェントの場合は、single_agent_train()を呼んで終わる。その中で、タイムステップまでのループが実装されている。なので、学習のメインルーチンはここになる。

👆いや、simultaneous_agentというやつを活用した方が良さそう。こちらは、エージェント毎の環境のスコープを指定できるっぽい。そして、スコープ毎にトランジションの記録だったり学習ができるっぽいので、勾配を良い感じに分けられる。これが良いです。

環境の番号毎に壊れる関節を指定して、それで学習すればまとめてモデルが作れそう。
ここで難しいのは、故障が発生した環境だけ学習させなくてはいけないし、環境毎に使うモデルが変わってくる事。これ並列化無理じゃね？いけるの？
ひとまずNNの推論については並列化できそう。

となるとどうなるんだ、
1. 全部の環境に対してNNでバッチ推論。推論結果はtensorでゲット
2. 1.のtensorで値が０でないやつを判別しその環境を取り出す
3. 値が0の環境に関しては健康モデルのまま推論する
4. 違うやつに関してはそれぞれのモデルを適用し、それでアクションを取り出す
   1. 2,3,4ではマスクを大量に作る必要がある。以下のマスクtensorが必要
      1. 健康状態のやつを表すマスクtensor
      2. それぞれのモデルを使うやつを表すマスクtensor(モデルの数必要)
5. アクションをそれぞれ取り出したら、1つのtensorにまとめる。
6. 1つのtensorにまとめたら環境に適用

分かってる事
- NNの推論は並列化可能
- actでの推論は何か副作用があるのか
  - そこまで大きな副作用は無さそうだが、mean_actionsとかに影響がありそう。単純に出力に対して、適さない環境分のノイズが入って結果が悪くなりそう。
- pytorch自体の機能としては必要なやつだけ取り出して後で必要な形に戻すのが可能であることが分かった。
- pytorchは必要なやつだけ推論するのができるとして、skrl.Agentが出来るのか調べる
  - agentのactはmodel.actに委譲する。で、それはcomputeに委譲されてる。で、これ以降は実装によるが、gausianのmlp実装だとstateをそのまま（state_preprocessorには入ってるけど）netに突っ込んでその出力が返ってくる。
    - なので、agent.actにstateを渡して返ってくるactionは普通にnetに突っ込んで出てくるとして良いだろう。
- agent._updateはpost_interaction()の中で呼ばれる。write_checkpointも呼ばれる。
  - agent毎に保存名を設定する方法はよく分からん。最悪最後にAgent.save()で適当にpathを指定してやればいいのでもう良いかなそれで。

しらべる事
- 学習したモデルの最終的な保存はどこでやってるんや
  - post_interactionの中のwrite_checkpointで呼ばれる



# やり方

- SequentialTrainerを改造する。
  - ひとまず健康環境のモデルを保持するためのagentを一つもつ。これはactだけ実行して学習はしない。
  - recordの実装が面倒なので、故障する部位は環境のインデックスによって固定する
  - trainの中身
    - まず、全環境のstateをNNに突っ込んで出力を出す
    - 出力に応じてmaskを作って、それによって取り出した環境だけ対応するagentに突っ込む
      - ここでmaskは後でも使うので全て取っておく。maskは壊れた関節のIDとかに応じてmappingしておくかな
    - 出てきた出力をactionsとしてまとめる
    - env.stepする
    - record_transitionする。この時、maskで取り出したやつだけ対応するagentに保存するようにする。健康状態には勿論やらない。
    - post_interactionする。当然健康状態のagentにはこれは実行しない。
  - 保存についてはよく分からないので、もう最後に全部save()を呼んで保存で良いかな。
  - 冷静に考えてみると、関節の故障状況でマスクすればいいだけなので、わざわざscopeとか頑張って設定する必要なかったわ。record_transitionもマスクテンソルで取り出せばどうとでもなったわ。
  - agentは全て同じコンフィグで起動する
  - reward以外のやつはマスクで取り出した大きさにしてみる




# デバッグ

- なんかjoint_failureをプリントしてみると、一回全部がTrueになっている時があった。これは何...？とは言え、たった一周期だけだったのでネットワークが一瞬変な出力をしただけの可能性はある
  - そもそも出力が連続していないかもしれない。検出本当にできているのか？これは？